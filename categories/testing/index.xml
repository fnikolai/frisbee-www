<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>testing on </title>
    <link>https://frisbee.dev/categories/testing/</link>
    <description>Recent content in testing on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://frisbee.dev/categories/testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hello World</title>
      <link>https://frisbee.dev/docs/walkthrough/hello-world/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/hello-world/</guid>
      <description>Let&#39;s start by creating a very simple workflow template to echo &amp;quot;hello world&amp;quot; using the docker/whalesay container image from Docker Hub.
You can run this directly from your shell with a simple docker command:
$ docker run docker/whalesay cowsay &amp;#34;hello world&amp;#34; _____________ &amp;lt; hello world &amp;gt; ------------- \ \ \ ## . ## ## ## == ## ## ## ## === /&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;&amp;#34;___/ === ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ / ===- ~~~ \______ o __/ \ \ __/ \____\______/ Hello from Docker!</description>
    </item>
    
    <item>
      <title>Parameters</title>
      <link>https://frisbee.dev/docs/walkthrough/parameters/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/parameters/</guid>
      <description>Let&#39;s look at a slightly more complex workflow spec with parameters.
Parameterized Template apiVersion: frisbee.dev/v1alpha1 kind: Template	metadata: name: whalesay	spec: # invoke the whalesay template with # &amp;#34;hello world&amp;#34; as the default argument # to the message parameter inputs:	parameters: message: &amp;#34;hello-world&amp;#34; service: containers: - name: app image: docker/whalesay command: [cowsay] args: [&amp;#34;{{.Inputs.Parameters.message}}&amp;#34;] This time, the whalesay template takes an input parameter named message that is passed as the args to the cowsay command.</description>
    </item>
    
    <item>
      <title>Execution Order</title>
      <link>https://frisbee.dev/docs/walkthrough/execution-order/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/execution-order/</guid>
      <description>Frisbee allows you to define the workflow as a directed-acyclic graph (DAG) by specifying the dependencies of each action. When you do so, the Frisbee scheduler ensures that your action is run only after the specified dependencies have successfully completed. After they succeed, the dependent action transitions from UNINTIALIZED to PENDING and then to RUNNING. If any of the job dependencies fail, the scenario automatically transitions from PENDING to FAILED.</description>
    </item>
    
    <item>
      <title>Dependency Order</title>
      <link>https://frisbee.dev/docs/walkthrough/dependency-order/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/dependency-order/</guid>
      <description>In the Execution Order example, one action starts after a previous action is complete. This kind of semantic is useful for batch jobs, but not for distributed computing. This is because services (and servers in general) are usually long-running that never complete.
In addition to the success semantics, Frisbee workflows also support running semantics. If used, a new action starts after a previous action is still running.
Iperf Templates Similarly to what we did in the hello-world example, we must create the templates that will be used in the testing scenario.</description>
    </item>
    
    <item>
      <title>Clustering</title>
      <link>https://frisbee.dev/docs/walkthrough/clustering/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/clustering/</guid>
      <description>When writing testing scenarios, it is often very useful to be able to run multiple services in a shared execution context.
Create Clustered Services There are two ways to create multiple services in a cluster: identical and parameterized.
Multiple Identical Services The following snippet will create 4 identical services initialized with the given input (in the input is not defined, the default template values will be used).
apiVersion: frisbee.dev/v1alpha1 kind: Scenario metadata: name: clustering spec: actions: # Create an iperf server - action: Service name: server service: templateRef: iperf.</description>
    </item>
    
    <item>
      <title>Scheduling</title>
      <link>https://frisbee.dev/docs/walkthrough/scheduling/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/scheduling/</guid>
      <description>Users may also set the creation policy to construct variable workloads and dynamically changing topologies for elastic experiments.
Scheduling The next snippet shows how to schedule the creation of new services, using a cron-like syntax.
--- apiVersion: frisbee.dev/v1alpha1 kind: Scenario metadata: name: scheduling spec: actions: - action: Service name: server service: templateRef: iperf.server - action: Cluster name: clients depends: { running: [ server ] } cluster: templateRef: iperf.client inputs: - { target: server, duration: &amp;#34;10&amp;#34; } - { target: server, duration: &amp;#34;20&amp;#34; } - { target: server, duration: &amp;#34;30&amp;#34; } # Schedule the creation of new clients schedule: cron: &amp;#34;@every 1m&amp;#34; All that it takes, it to add the scheduling fields and specify the desired cron, and you will get an output like this one:</description>
    </item>
    
    <item>
      <title>Conditionals</title>
      <link>https://frisbee.dev/docs/walkthrough/conditionals/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/conditionals/</guid>
      <description>We also support conditional execution. The syntax is implemented by govaluate which offers the support for complex syntax.
Conditionals apiVersion: frisbee.dev/v1alpha1 kind: Scenario metadata: name: conditionals spec: actions: - action: Service name: server service: templateRef: iperf.server - action: Cluster name: clients depends: { running: [ server ] } cluster: templateRef: iperf.client instances: 10 inputs: - { target: server, duration: &amp;#34;10&amp;#34; } - { target: server, duration: &amp;#34;20&amp;#34; } - { target: server, duration: &amp;#34;30&amp;#34; } schedule: cron: &amp;#34;@every 1m&amp;#34; # Suspend the execution if more than 6 clients are created until: state: &amp;#39;{{.</description>
    </item>
    
    <item>
      <title>Tolerate Failures</title>
      <link>https://frisbee.dev/docs/walkthrough/tolerate-failures/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/tolerate-failures/</guid>
      <description>Systems fail. After all, this is what testing is about.
By default, Frisbee has a builtin fail-fast mechanism that aborts the experiment when a fault is sensed.
Tolerate Failures Template Instead of waiting for a service to fail, let&#39;s give it some boost.
We have modified the previous template to take the exit code as an input.
--- apiVersion: frisbee.dev/v1alpha1 kind: Template metadata: name: iperf.client spec: inputs: parameters: target: localhost duration: &amp;#34;60&amp;#34; exit: &amp;#34;false&amp;#34; # Take exit code as an input service: containers: - name: app image: czero/iperf2 command: - /bin/sh # Run shell - -c # Read from string - | # Multi-line str # Compare the input, and exit if needed [[ {{.</description>
    </item>
    
    <item>
      <title>Resource Throttling</title>
      <link>https://frisbee.dev/docs/walkthrough/resource-throttling/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/resource-throttling/</guid>
      <description>In Kubernetes, when you create a specification for a pod, you can optionally specify how many resources each container is allowed to use on a Kubernetes node. The most common resources are CPU and memory (RAM), but you can also specify others.
But, what happens when you have parameterized services? How can you give parameterized resources?
Frisbee address this issue via tha decorators abstraction.
Decorators rewrite the pod&#39;s specification according to some rules, before submitting the pod for creation.</description>
    </item>
    
    <item>
      <title>Placement</title>
      <link>https://frisbee.dev/docs/walkthrough/placement/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/placement/</guid>
      <description>Kubernetes already provide a powerful mechanism control which node the Pod deploys to. For example, to ensure that a Pod ends up on a node with an SSD attached to it, or to co-locate Pods from two different services that communicate a lot into the same availability zone.
However, configuring these mechanisms is cumbersome. Especially when we talk about tens of dynamically created services. For this reason, Frisbee provides simple abstraction for controlling the placement at the level of a cluster.</description>
    </item>
    
    <item>
      <title>Remote Calls</title>
      <link>https://frisbee.dev/docs/walkthrough/remote-calls/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/remote-calls/</guid>
      <description>There are cases where you need to get a shell to a running container.
For this reason, Frisbee provides the Call primitive.
Hints:
The number of expected outputs must be the same as the number of defined services. Because the Call primitive is synchronous, it may block the scenario if the referenced services does not exist. The expected output for and stdout and stderr is a regex. For &amp;quot;raw&amp;quot; matching, the expression cannot be more than 1024 characters.</description>
    </item>
    
    <item>
      <title>Assertions</title>
      <link>https://frisbee.dev/docs/walkthrough/assertions/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/assertions/</guid>
      <description>No testing framework can be complete without assertions.
Let&#39;s see how to use them properly.
In the following scenario, we:
Run a server that terminates gracefully after a few seconds
Run a set of clients
Evaluate the outcome with and without assertions.
Assertions Template for gracefully terminated server Firstly, let&#39;s make a server that gracefully terminates after a few seconds.
--- apiVersion: frisbee.dev/v1alpha1 kind: Template metadata: name: iperf.server spec: service: containers: - name: app image: czero/iperf2 command: - /bin/sh # Run shell - -c # Read from string - | # Multi-line str # Run the iperf server in the background iperf -s -f -m -i 5 &amp;amp; # Gracefully terminate after the given period sleep 60 &amp;amp;&amp;amp; exit 0 Scenario, Without Assertions Then, let&#39;s run our usual scenario.</description>
    </item>
    
    <item>
      <title>Naming and Addressing</title>
      <link>https://frisbee.dev/docs/walkthrough/naming/</link>
      <pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://frisbee.dev/docs/walkthrough/naming/</guid>
      <description>In contrast to other Workflow enginers like Argo that use dynamically generated names, all objects in Frisbee follow a predictable naming pattern. This makes it possible to create communicating services.
Reference an Object In case of communicating services, such as a client-server architecture, we need the client to know the name of the server in other to establish a communication case.
apiVersion: frisbee.dev/v1alpha1 kind: Scenario metadata: name: server-client spec: actions: - action: Service name: server service: templateRef: iperf2.</description>
    </item>
    
  </channel>
</rss>
